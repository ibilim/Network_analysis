
##Salary and Connection predictions 

# # Assignment 4

# In[1]:


import networkx as nx
import pandas as pd
import numpy as np
import pickle
#degrees=P1_Graphs[0].degree()
#degrees.value()
#import matplotlib.pyplot as plt
#for i in range(0,len(P1_Graphs)):
#    degrees=P1_Graphs[i].degree()
#    fig,ax=plt.subplots()
#    plt.hist(sorted(degrees.values()))
#    plt.title('ave_clustring: '+ str(nx.average_clustering(P1_Graphs[i]))+'\n'+'ave_shortest_path: '+str(nx.average_shortest_path_length(P1_Graphs[i])))
#    plt.show()
    #print(sorted(degrees.values()))
    # 1: PA
    #  2: SM_L
    # 3: SW _L
    # 4:PA
    # 5: SW_H


# ---
# 
# ## Part 1 - Random Graph Identification
# 
# For the first part of this assignment you will analyze randomly generated graphs and determine which algorithm created them.

# In[2]:


P1_Graphs = pickle.load(open('A4_graphs','rb'))
#P1_Graphs


# <br>
# `P1_Graphs` is a list containing 5 networkx graphs. Each of these graphs were generated by one of three possible algorithms:
# * Preferential Attachment (`'PA'`)
# * Small World with low probability of rewiring (`'SW_L'`)
# * Small World with high probability of rewiring (`'SW_H'`)
# 
# Anaylze each of the 5 graphs and determine which of the three algorithms generated the graph.
# 
# *The `graph_identification` function should return a list of length 5 where each element in the list is either `'PA'`, `'SW_L'`, or `'SW_H'`.*

# In[3]:


def graph_identification():
    
    # Your Code Here
    
    return ['PA','SW_L','SW_L','PA','SW_H']# Your Answer Here
graph_identification()


# ---
# 
# ## Part 2 - Company Emails
# 
# For the second part of this assignment you will be workking with a company's email network where each node corresponds to a person at the company, and each edge indicates that at least one email has been sent between two people.
# 
# The network also contains the node attributes `Department` and `ManagementSalary`.
# 
# `Department` indicates the department in the company which the person belongs to, and `ManagementSalary` indicates whether that person is receiving a management position salary.

# In[38]:


G = nx.read_gpickle('email_prediction.txt')


# ### Part 2A - Salary Prediction
# 
# Using network `G`, identify the people in the network with missing values for the node attribute `ManagementSalary` and predict whether or not these individuals are receiving a management position salary.
# 
# To accomplish this, you will need to create a matrix of node features using networkx, train a sklearn classifier on nodes that have `ManagementSalary` data, and predict a probability of the node receiving a management salary for nodes where `ManagementSalary` is missing.
# 
# 
# 
# Your predictions will need to be given as the probability that the corresponding employee is receiving a management position salary.
# 
# The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
# 
# Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).
# 
# Using your trained classifier, return a series of length 252 with the data being the probability of receiving management salary, and the index being the node id.
# 
#     Example:
#     
#         1       1.0
#         2       0.0
#         5       0.8
#         8       1.0
#             ...
#         996     0.7
#         1000    0.5
#         1001    0.0
#         Length: 252, dtype: float64

# In[48]:


def salary_predictions():
    from sklearn.model_selection import train_test_split
    from sklearn.ensemble import RandomForestClassifier
    df=pd.DataFrame(index=G.nodes())
    df['Department']=pd.Series(nx.get_node_attributes(G,'Department'))
    df['ManagementSalary']=pd.Series(nx.get_node_attributes(G,'ManagementSalary'))
    df['Degrees']=pd.Series([i for i in G.degree().values()])
    df['Degree_centrality']=pd.Series([i for i in nx.degree_centrality(G).values()])
    df['Closeness_centrality']=pd.Series([i for i in nx.closeness_centrality(G).values()])
    df['Betweennes']=pd.Series([i for i in nx.betweenness_centrality(G,normalized=True,endpoints=False,k=20).values()])
    df_mngmt=df[df['ManagementSalary']>=0]
    x=df_mngmt[['Department','Degrees','Degree_centrality','Closeness_centrality','Betweennes']]
    y=df_mngmt['ManagementSalary']
    df_mngmt_none=df[(df['ManagementSalary']!=0) & (df['ManagementSalary']!=1)]
    to_predict=df_mngmt_none[['Department','Degrees','Degree_centrality','Closeness_centrality','Betweennes']]
    X_train,X_test,y_train,y_test=train_test_split(x,y,random_state=0)
    lin_reg=RandomForestClassifier(n_estimators=1000,max_depth=4).fit(X_train, y_train)
    
    # Your Code Here
    return pd.Series([ float('{:.1f}'.format(i)) for i in lin_reg.predict_proba(to_predict)[:,1]],index= df_mngmt_none.index) # Your Answer Here
salary_predictions()


# ### Part 2B - New Connections Prediction
# 
# For the last part of this assignment, you will predict future connections between employees of the network. The future connections information has been loaded into the variable `future_connections`. The index is a tuple indicating a pair of nodes that currently do not have a connection, and the `Future Connection` column indicates if an edge between those two nodes will exist in the future, where a value of 1.0 indicates a future connection.

# In[44]:


future_connections = pd.read_csv('Future_Connections.csv', index_col=0, converters={0: eval})
#future_connections.head(10)


# Using network `G` and `future_connections`, identify the edges in `future_connections` with missing values and predict whether or not these edges will have a future connection.
# 
# To accomplish this, you will need to create a matrix of features for the edges found in `future_connections` using networkx, train a sklearn classifier on those edges in `future_connections` that have `Future Connection` data, and predict a probability of the edge being a future connection for those edges in `future_connections` where `Future Connection` is missing.
# 
# 
# 
# Your predictions will need to be given as the probability of the corresponding edge being a future connection.
# 
# The evaluation metric for this assignment is the Area Under the ROC Curve (AUC).
# 
# Your grade will be based on the AUC score computed for your classifier. A model which with an AUC of 0.88 or higher will receive full points, and with an AUC of 0.82 or higher will pass (get 80% of the full points).
# 
# Using your trained classifier, return a series of length 122112 with the data being the probability of the edge being a future connection, and the index being the edge as represented by a tuple of nodes.
# 
#     Example:
#     
#         (107, 348)    0.35
#         (542, 751)    0.40
#         (20, 426)     0.55
#         (50, 989)     0.35
#                   ...
#         (939, 940)    0.15
#         (555, 905)    0.35
#         (75, 101)     0.65
#         Length: 122112, dtype: float64

# In[45]:


def new_connections_predictions():
    from sklearn.model_selection import train_test_split
    from sklearn.ensemble import RandomForestClassifier
    from networkx import algorithms
    df_fc=future_connections    
    df_fc['common_neighbours']=pd.Series([len(list(nx.common_neighbors(G,df_fc.index[i][0],df_fc.index[i][1]))) for i in range(0,len(df_fc))],index=df_fc.index)
    df_fc['jaccard_dist']=pd.Series([i for a,b,i in nx.jaccard_coefficient(G,ebunch=df_fc.index)],index=df_fc.index)
    df_fc['resource_allocation']=pd.Series([i for a,b,i in nx.resource_allocation_index(G,ebunch=df_fc.index)],index=df_fc.index)
    df_fc['adamic_acar']=pd.Series([i for a,b,i in nx.adamic_adar_index(G,ebunch=df_fc.index)],index=df_fc.index)
    df_fc['pref_attach']=pd.Series([i for a,b,i in nx.preferential_attachment(G,ebunch=df_fc.index)],index=df_fc.index)
    df_fc_nomiss=df_fc[df_fc['Future Connection']>=0]
    x=df_fc_nomiss[['common_neighbours','jaccard_dist','resource_allocation','adamic_acar','pref_attach']]
    y=df_fc_nomiss['Future Connection']
    df_fc_miss=df_fc[(df_fc['Future Connection']!=0) & (df_fc['Future Connection']!=1)]
    
    to_predict=df_fc_miss[['common_neighbours','jaccard_dist','resource_allocation','adamic_acar','pref_attach']]
    X_train,X_test,y_train,y_test=train_test_split(x,y,random_state=0)
    lin_reg=RandomForestClassifier(n_estimators=100,max_depth=3).fit(X_train, y_train)
    
    return pd.Series([float('{:.2f}'.format(i)) for i in lin_reg.predict_proba(to_predict)[:,1]],index= df_fc_miss.index)
new_connections_predictions()# Your Answer Here


# In[ ]:




